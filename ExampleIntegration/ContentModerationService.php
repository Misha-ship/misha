<?phpnamespace App\Http\Service\GoogleML;class ContentModerationService{    const NEGATIVE = 'negative';    const POSITIVE = 'positive';    const NEUTRAL = 'neutral';    public const TOXIC = 'Toxic';    public const INSULT = 'Insult';    public const PROFANITY = 'Profanity';    public const DEROGATORY = 'Derogatory';    public const SEXUAL = 'Sexual';    public const DEATH_HARM_TRAGEDY = 'Death, Harm & Tragedy';    public const VIOLENT = 'Violent';    public const PUBLIC_SAFETY = 'Public Safety';    public const RELIGION_BELIEF = 'Religion & Belief';    public const ILLICIT_DRUGS = 'Illicit Drugs';    public const LEGAL = 'Legal';    public const MAGNITUDE = 'magnitude';    public const SCORE = 'score';    private const  YELLOW_PATTERNS = [        '/\+?[0-9]{1,4}?[-. ]?\(?\d{1,3}?\)?[-. ]?\d{1,4}[-. ]?\d{1,4}[-. ]?\d{1,9}/' => 'Text contains a phone number',        '/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}/' => 'Text contains an email address',        '/@[a-zA-Z0-9._]+/' => 'Text contains a social media mention',    ];    private const  RED_PATTERNS = [        '/\b(?:https?:\/\/|www\.)\S+\b/i' => 'Text contains a link',    ];    private array $thresholds = [        self::TOXIC => 0.4,        self::INSULT => 0.4,        self::PROFANITY => 0.4,        self::DEROGATORY => 0.4,        self::SEXUAL => 0.49,        self::DEATH_HARM_TRAGEDY => 0.4,        self::VIOLENT => 0.4,        self::PUBLIC_SAFETY => 0.7,        self::RELIGION_BELIEF => 0.7,        self::ILLICIT_DRUGS => 0.85,        self::LEGAL => 0.6,    ];    public function moderateContent($entities, $sentimentScore, $moderateScore, $sentimentScoreWords, $classifyText): array    {        foreach (self::YELLOW_PATTERNS as $pattern => $message) {            if ($this->containsPattern($entities, $pattern)) {                return $this->result(self::NEUTRAL, $message);            }        }        foreach (self::RED_PATTERNS as $pattern => $message) {            if ($this->containsPattern($entities, $pattern)) {                return $this->result(self::NEGATIVE, $message);            }        }        $problemCategories = $this->identifyProblemCategories($moderateScore);        if (!empty($problemCategories)) {            return $this->result(self::NEGATIVE, "The text contains inappropriate content in the following categories: " . implode(", ", $problemCategories));        }        if(empty($classifyText) && $sentimentScore[self::SCORE] < 0.62) {            return $this->result(self::NEUTRAL, 'Text not having sense');        }        return $this->evaluateSentiment($sentimentScore, $sentimentScoreWords);    }    private function containsPattern(array $entities, string $pattern): bool    {        foreach ($entities as $entity) {            foreach ($entity['mentions'] as $mention) {                if (preg_match($pattern, $mention['text']['content'])) {                    return true;                }            }        }        return false;    }    private function identifyProblemCategories($moderateScore): array    {        return collect($moderateScore)            ->filter(function ($category) {                return $category['confidence'] > ($this->thresholds[$category['name']] ?? 2);            })            ->pluck('name')            ->all();    }    private function evaluateSentiment($sentimentScoreWords): array    {        foreach ($sentimentScoreWords as $sentence) {            $score = $sentence['sentiment'][self::SCORE];            $magnitude = $sentence['sentiment'][self::MAGNITUDE];            if (($score < 0.1 && $score > -0.5) && $magnitude < 0.1) {                return $this->result(self::NEUTRAL, 'One or more sentences have a slightly negative sentiment');            } elseif ($score <= -0.5) {                return $this->result(self::NEGATIVE, 'One or more sentences have a strongly negative sentiment');            }        }        return $this->result(self::POSITIVE, 'The text is acceptable');    }    private function result(string $status, string $message): array    {        return ['result' => $status, 'message' => $message];    }}